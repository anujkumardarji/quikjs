#!/usr/bin/env node
import inquirer from"inquirer";import template from"./templates/content.js";import{prismaDataType,sequelizeDataType,typeORMDataType,mongooseDataType}from"./types.js";import fs from"fs";import path from"path";import{spawnSync}from"child_process";import genModel from"./model.js";import capitalize from"./utils/capitalize.js";let state;const projectRoot=process.cwd();const loadState=async input=>{try{const config=fs.readFileSync(path.join(projectRoot,"config.json"));if(config.length!==0){state=JSON.parse(config)}}catch(error){state=input}};const orms={prisma:{id:1,name:"prisma",getType:input=>prismaDataType(input)},sequelize:{id:2,name:"sequalize",getType:input=>sequelizeDataType(input)},mongoose:{id:3,name:"mongoose",getType:input=>mongooseDataType(input)},typeORM:{id:4,name:"typeORM",getType:input=>typeORMDataType(input)}};let tables=[];async function promptSchemaModel(input){try{let schemaData={};let confirm=true;let types=["string","integer","float","boolean","date","uuid","json","enum","array","binary","decimal"];types=types.map((type=>orms[input.orm].getType(type)));const schemaQuestions=[{type:"input",name:"name",message:"Enter the name of the attribute:",validate:function(value){return/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)?true:"Please enter a valid attribute name (alphanumeric characters and underscores only, and must start with a letter or underscore)."}},{type:"list",name:"type",message:"Select the data type:",choices:types},{type:"input",name:"size",message:"Enter the size (if applicable):",when:answers=>!["BOOLEAN","DATE"].includes(answers.type),validate:function(value){return/^\d+$/.test(value)?true:"Please enter a valid size (a positive integer)."}},{type:"input",name:"defaultValue",message:"Enter the default value (if any):",default:null,validate:function(value){return value.trim().length===0||/^[a-zA-Z0-9_]+$/.test(value)?true:"Please enter a valid default value (alphanumeric characters and underscores only)."}},{type:"confirm",name:"primaryKey",message:"Is this attribute a primary key?",default:true},{type:"confirm",name:"allowNulls",message:"Allow NULL values for this attribute?",when:answers=>!answers.primaryKey,default:true},{type:"confirm",name:"unique",message:"Should this attribute have unique values?",when:answers=>!answers.primaryKey,default:false},{type:"confirm",name:"autoIncrement",message:"Should this attribute auto-increment?",default:false},{type:"confirm",name:"foreignKey",message:"Is this attribute a foreign key?",default:true},{type:"list",name:"refTable",message:"Select the referenced table:",choices:tables,when:answers=>answers.foreignKey},{type:"list",name:"refField",message:"Enter the referenced field:",when:answers=>answers.foreignKey,choices:function(answers){const refTable=answers.refTable;const fields=schemaData[refTable].map((field=>field.name));return fields}},{type:"list",name:"relationshipType",message:"Select the relationship type:",choices:["One-to-One","One-to-Many","Many-to-One","Many-to-Many"],when:answers=>answers.foreignKey},{type:"confirm",name:"add_another",message:"Do you want to add another attribute?",default:true}];while(confirm){let add_attributes=true;const ans=await inquirer.prompt([{type:"confirm",name:"add_table",message:"Do you want to add a table?",default:true},{type:"input",name:"table_name",message:"Enter the table name?",when:answers=>answers.add_table}]);if(!ans.add_table){confirm=false;break}schemaData[ans.table_name]=[];tables.push(ans.table_name);while(add_attributes){const model=await inquirer.prompt(schemaQuestions);if(!model.add_another){schemaData[ans.table_name].push(model);add_attributes=false;break}schemaData[ans.table_name].push(model)}}return schemaData}catch(e){console.log("error getting schema details\n"+e)}}function transformFields(fields){const transformedFields={};fields.forEach((field=>{transformedFields[field.field_name]=field.field_type}));return transformedFields}function migrateAndGeneratePrisma(){return new Promise(((resolve,reject)=>{try{const migrateDevProcess=spawnSync("npx",["prisma","migrate","dev"],{input:"\n",encoding:"utf-8",stdio:"inherit"});if(migrateDevProcess.error){console.log("Prisma migrate dev failed")}else{console.log("Prisma migrate dev completed")}const generateProcess=spawnSync("npx",["prisma","generate"],{stdio:"inherit"});if(generateProcess.error){console.log("Prisma generate failed")}else{console.log("Prisma generate completed")}resolve()}catch(error){console.error("Prisma migrate or generate failed:",error);reject(error)}}))}async function setupPrisma(serviceName,model,db){try{console.log("start orm model setup");genModel.generatePrismaModel(serviceName,model,db);console.log("start migration");await migrateAndGeneratePrisma()}catch(error){console.log("Error setting up Prisma:",error)}}function controllersPrisma(serviceName){const controllerContent=`const prisma = require('../config/db');\n\n  ${template.createPrismaContent(serviceName)}\n  ${template.getAllPrismaContent(serviceName)}\n  ${template.getByIdPrismaContent(serviceName)}\n  ${template.updatePrismaContent(serviceName)}\n  ${template.deletePrismaContent(serviceName)}\n  \n  module.exports = {\n    create${capitalize(serviceName)},\n    getAll${capitalize(serviceName)},\n    get${capitalize(serviceName)}ById,\n    update${capitalize(serviceName)}ById,\n    delete${capitalize(serviceName)}ById\n  };\n    `;fs.writeFileSync(path.join(projectRoot,"controllers",`${serviceName}.js`),controllerContent)}function isArrayNotEmpty(arr){return Array.isArray(arr)&&arr.length>0}function controllersSequelize(serviceName){const controllerContent=`\n  const db = require('../models/index');\n\n  ${template.createSequelizeContent(serviceName)}\n  ${template.getAllSequelizeContent(serviceName)}\n  ${template.getByIdSequelizeContent(serviceName)}\n  ${template.updateSequelizeContent(serviceName)}\n  ${template.deleteSequelizeContent(serviceName)}\n  \n  module.exports = {\n    create${capitalize(serviceName)},\n    getAll${capitalize(serviceName)},\n    get${capitalize(serviceName)}ById,\n    update${capitalize(serviceName)}ById,\n    delete${capitalize(serviceName)}ById\n  };\n  `;const controllerFilePath=path.join(projectRoot,"controllers",`${serviceName}.js`);fs.writeFileSync(controllerFilePath,controllerContent)}async function setupSequalize(serviceName,model,relations){try{console.log("generating model");genModel.generateSequelizeModel(serviceName,model);if(isArrayNotEmpty(relations))generateAssociations(serviceName,relations);console.log("model generation complete")}catch(error){console.log("Error setting up Prisma:",error)}}function generateAssociations(modelName,relations){relations.forEach((({model_name:model_name,relation_type:relation_type})=>{const associationCode=generateAssociationCode(modelName,model_name,relation_type);appendToFile(`${modelName}.js`,associationCode);appendToFile(`${model_name}.js`,generateInverseAssociationCode(modelName,model_name,relation_type))}))}function generateAssociationCode(modelName,relatedModelName,type){const capitalize=str=>str.charAt(0).toUpperCase()+str.slice(1);let associationCode=`// Define association with ${capitalize(relatedModelName)}\n\n  const ${capitalize(relatedModelName)} = require('./${relatedModelName.toLowerCase()}');\n\n  `;if(type.toLowerCase()==="one-to-many"){associationCode+=`${capitalize(modelName)}.hasMany(${capitalize(relatedModelName)});\n`}else if(type.toLowerCase()==="many-to-one"){associationCode+=`${capitalize(modelName)}.belongsTo(${capitalize(relatedModelName)});\n`}else if(type.toLowerCase()==="many-to-many"){associationCode+=`${capitalize(modelName)}.belongsToMany(${capitalize(relatedModelName)});\n`}else if(type.toLowerCase()==="one-to-one"){associationCode+=`${capitalize(modelName)}.hasOne(${capitalize(relatedModelName)});\n`}return associationCode}function generateInverseAssociationCode(modelName,relatedModelName,type){const capitalize=str=>str.charAt(0).toUpperCase()+str.slice(1);let inverseAssociationCode=`// Define inverse association with ${capitalize(modelName)}\n\n  const ${capitalize(modelName)} = require('./${modelName.toLowerCase()}');\n\n  `;if(type.toLowerCase()==="one-to-many"){inverseAssociationCode+=`${capitalize(relatedModelName)}.belongsTo(${capitalize(modelName)});\n`}else if(type.toLowerCase()==="many-to-one"){inverseAssociationCode+=`${capitalize(relatedModelName)}.hasMany(${capitalize(modelName)});\n`}else if(type.toLowerCase()==="many-to-many"){inverseAssociationCode+=`${capitalize(relatedModelName)}.belongsToMany(${capitalize(modelName)});\n`}else if(type.toLowerCase()==="one-to-one"){inverseAssociationCode+=`${capitalize(relatedModelName)}.hasOne(${capitalize(modelName)});\n`}return inverseAssociationCode}function appendToFile(fileName,content){const filePath=path.join(projectRoot,"models",fileName);fs.appendFileSync(filePath,content)}async function generateScaffold(serviceName,model,relations=[],roles=[]){try{const db=state.db;const orm=state.orm;console.log("started generating scaffold...");switch(orm){case"prisma":await setupPrisma(serviceName,model,db);controllersPrisma(serviceName);break;case"sequelize":await setupSequalize(serviceName,model,relations);controllersSequelize(serviceName);break}generateRoutes(serviceName,roles);console.log("done generating routes and controllers")}catch(error){console.error("Error generating scaffold:",error)}}function authMiddleware(roles){if(state.authentication&&roles.length){return`userAuth, checkRole(${JSON.stringify(roles)}), `}else if(state.authentication){return"userAuth, "}return""}function generateRoutes(serviceName,roles){const mainFilePath=path.join(projectRoot,"app.js");fs.writeFileSync(path.join(projectRoot,"routes",`${serviceName}.js`),template.routesContent(serviceName));const importContent=`const ${serviceName}Routes = require("./routes/${serviceName}");`;const routeContent=`app.use("/api/${serviceName}",${authMiddleware(roles)}${serviceName}Routes);`;let mainFileContent=fs.readFileSync(mainFilePath,"utf-8");let lines=mainFileContent.split("\n");const importRoutesIndex=lines.findIndex((line=>line.includes("// Import routes")));if(importRoutesIndex!==-1&&!lines.some((line=>line.includes(importContent)))){lines.splice(importRoutesIndex+1,0,importContent);fs.writeFileSync(mainFilePath,lines.join("\n"))}mainFileContent=fs.readFileSync(mainFilePath,"utf-8");lines=mainFileContent.split("\n");const useRoutesIndex=lines.findIndex((line=>line.includes("// Routes")));if(useRoutesIndex!==-1&&!lines.some((line=>line.includes(routeContent)))){lines.splice(useRoutesIndex+1,0,routeContent);fs.writeFileSync(mainFilePath,lines.join("\n"))}}function updateState(data){console.log("Updating project state");let config=fs.readFileSync(path.join(projectRoot,"config.json"),"utf-8");config=JSON.parse(config);config.models.push(data);console.log(config);fs.writeFileSync(path.join(projectRoot,"config.json"),JSON.stringify(config));return config}const scaffold=async input=>{try{await loadState(input);const schemaData=await promptSchemaModel(input);console.log("Form Data:",schemaData);if(Object.keys(schemaData).length){for(const[key,value]of Object.entries(schemaData)){await generateScaffold(key,value)}}const name=key;const model=transformFields(fields);if(modelExists){console.log("model/service already exist")}else{relations=isArrayNotEmpty(relations)?relations:[]}console.log(`API GENERATED/MODIFIED FOR SERVICE '${name}' FOR PROJECT '${state.projectName}' USING DATABASE '${req.body.db}'`)}catch(err){console.log("something went wrong")}};export default scaffold;